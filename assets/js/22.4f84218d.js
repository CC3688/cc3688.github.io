(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{220:function(n,a,t){"use strict";t.r(a);var e=t(28),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"basic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic"}},[n._v("#")]),n._v(" basic")]),n._v(" "),t("h2",{attrs:{id:"vscode-自动编译-ts-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vscode-自动编译-ts-文件"}},[n._v("#")]),n._v(" vscode 自动编译 .ts 文件")]),n._v(" "),t("ol",[t("li",[n._v("在根目录下  运行"),t("code",[n._v("tsc --init")]),n._v("  生成配置文件")]),n._v(" "),t("li",[n._v("在配置文件 设置 outDir  编译后 js 文件的输出目录")]),n._v(" "),t("li",[n._v("点击vscode 菜单 > Terminal > Run Task > typescript > tsc:watch - tsconfig.json")])]),n._v(" "),t("p",[n._v("设置完成后就可以自动生成代码")]),n._v(" "),t("h2",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[n._v("#")]),n._v(" 数据类型")]),n._v(" "),t("p",[n._v("typescript 中为了使编写的代码更规范, 更有利于维护, 增加了类型校验")]),n._v(" "),t("p",[n._v("写 ts 代码必须指定类型")]),n._v(" "),t("ul",[t("li",[n._v("布尔类型 (boolean)")]),n._v(" "),t("li",[n._v("数字类型 (number)")]),n._v(" "),t("li",[n._v("字符串类型 (string)")]),n._v(" "),t("li",[n._v("数组类型 (array)")]),n._v(" "),t("li",[n._v("元组类型 (tuple)")]),n._v(" "),t("li",[n._v("枚举类型 (enum)")]),n._v(" "),t("li",[n._v("任意类型 (any)")]),n._v(" "),t("li",[n._v("null 和 undefined")]),n._v(" "),t("li",[n._v("void 类型")]),n._v(" "),t("li",[n._v("never 类型")])]),n._v(" "),t("h4",{attrs:{id:"布尔类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型"}},[n._v("#")]),n._v(" 布尔类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let flag: boolean = true\n\n// flag =  123   //错误\n\nflag = flase   // 正确\n\n")])])]),t("h4",{attrs:{id:"数值类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数值类型"}},[n._v("#")]),n._v(" 数值类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let num: number = 123\n\nnum = 456\n\n// num = 'str'  // 错误\n\n")])])]),t("h4",{attrs:{id:"字符串类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串类型"}},[n._v("#")]),n._v(" 字符串类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let str: string = 'this is ts'\n\nstr = 'haha'  //正确\n\n//str = true    //错误\n\n")])])]),t("h4",{attrs:{id:"数组类型-array-ts中定义数组有两种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组类型-array-ts中定义数组有两种方式"}},[n._v("#")]),n._v(" 数组类型(array)  ts中定义数组有两种方式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 1 第一种定义数组的方式\nlet arr: number[] = [11,22,33]\n\n// 2 第二种定义数组的方式\nlet arr2: Array<number> = [11,22,33]\n\n")])])]),t("h4",{attrs:{id:"元组类型-tuple-属于数组的一种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元组类型-tuple-属于数组的一种"}},[n._v("#")]),n._v(" 元组类型(tuple)  属于数组的一种")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 可以给数组中的每个元素指定类型\n\nlet arr: [number, string] = [123, 'this is ts']\n")])])]),t("h4",{attrs:{id:"枚举类型-enum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举类型-enum"}},[n._v("#")]),n._v(" 枚举类型(enum)")]),n._v(" "),t("p",[n._v("在程序中用自然语言中相应含义的单词来代表某一状态,使程序容易阅读和理解,也就是说,事先考虑到某一个变量可能取的值, 尽量用自然语言中含义清楚的单词来表示它的每一个值. 这种方法称为枚举, 用这种方法的类型称枚举类型.")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// enum Flag { success, error}\nenum Flag { success = 1, error = 2}\n\nlet s: Flag = Flag.success\n\nconsole.log(s)   // 1\n\nenum Color { blue, red, 'orange'}  // 加不加引号 一样\nlet c: Color = Color.red\nconsole.log(c)   // 1\n\n//默认一项项的值是从0开始 递增 1   如果有赋值, 则后面的值由赋值后开始 递增 1\n")])])]),t("h4",{attrs:{id:"任意类型-any"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任意类型-any"}},[n._v("#")]),n._v(" 任意类型(any)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nlet num: any = 123\n\nnum = 'abc'\n\nnum = true\n\n// 使用\nlet oBox: any = document.getElementById('box')\n\noBox.style.color = 'red'\n\n")])])]),t("h4",{attrs:{id:"null-和-undefined-其它数据类型的子类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-其它数据类型的子类型"}},[n._v("#")]),n._v(" null 和 undefined  其它数据类型的子类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n// let num: number\n\n// console.log(num)     // 可以输出 undefined  报错\n\n\n\n// let num2: undefined\n// console.log(num2)   //输出 undefined  正确\n\nlet num: number | undefined\n\nnum = 123\n\nconsole.log(num)   // 123\n\n// 一个元素可能是number 类型, 可能是 null  可能是 undefined\n\nlet num: number|null|undefined\n\n")])])]),t("h4",{attrs:{id:"void类型-void表示没有任何类型-一般用于定义方法时-方法没有返回值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#void类型-void表示没有任何类型-一般用于定义方法时-方法没有返回值"}},[n._v("#")]),n._v(" void类型  void表示没有任何类型, 一般用于定义方法时, 方法没有返回值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function run (): void {\n\n}\n \n")])])]),t("h4",{attrs:{id:"never-类型-是其他类型-包括-null-和-undefined的子类型-代表从不会出现的值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#never-类型-是其他类型-包括-null-和-undefined的子类型-代表从不会出现的值"}},[n._v("#")]),n._v(" never 类型: 是其他类型, 包括 null 和 undefined的子类型, 代表从不会出现的值")]),n._v(" "),t("p",[n._v("意味着声明never的变量只能被never类型所赋值")]),n._v(" "),t("h2",{attrs:{id:"函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[n._v("#")]),n._v(" 函数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 函数声明法\nfunction run():strng {\n\n  return 'run'\n}\n\n\n// 匿名函数\nconst fun = function(): number {\n\n  return 123\n}\n\n// 传参\nfunction getInfo(name: string, age: number): string {\n\n  return `${name} --- ${age}`\n}\n\n\n// 可选参数,  参数名 带 ? 就是可选参数,  可选参数 必须在位置参数后面z\nfunctionn getInfo(name: string, age?:number):string {\n\n}\n\n\n// 三点运算符,  剩余参数, 接受新参传过来的值\n\nfunction sum(a:number, b:number: ...result: number[]): number {\n  var sum = 0\n  for( var i = 0; i < result.lenghth; i++) {\n    sum += result[i]\n  }\n  return sum\n}\n\n// ts函数重载\n// java中方法的重载, 重载指的是两个或者两个以上同名函数, 但它们的参数不一样, 这里会出现函数重载的情况\n// typescript中的重载, 通过为同一个函数提供多个函数类型定义来试下多种功能的目的\n// ts为了兼容\nfunction getInfo(name: string):string;\nfunction getInfo(age:number):number;\nfunction getInfo(str:any):any {\n  if (typeof str === 'string') {\n    return str;\n  } else {\n    return str;\n  }\n}\n\n")])])]),t("h2",{attrs:{id:"类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),t("h4",{attrs:{id:"ts类的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts类的定义"}},[n._v("#")]),n._v(" ts类的定义")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Person {\n  name: string;    // 属性, 前面省略了 public 关键字\n\n  constructor(name: string) {   //构造函数   实例化类的时候  触发的函数\n\n  }\n\n  getName():string {\n    return this.name;\n  }\n\n  setName(name:string):void {\n    this.name = name;\n  }\n\n  run(): void {   // 方法\n     \n  }\n}\n\n// 使用\nvar p = new Person("张三")\n\n')])])]),t("h4",{attrs:{id:"ts继承-extends-super"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts继承-extends-super"}},[n._v("#")]),n._v(" ts继承 extends super")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Student extends Person {\n  constructor(name:string) {\n    super(name);              // 初始化父类的构造函数\n  }\n\n  run():void{\n    //子类与父类  有同样的方法,  会覆盖掉父类的方法\n  }\n}\n\n")])])]),t("h4",{attrs:{id:"修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[n._v("#")]),n._v(" 修饰符")]),n._v(" "),t("p",[n._v("ts定义属性的有三种修饰符")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("public : 公有   在类里面, 子类,  类外面都可以访问")])]),n._v(" "),t("li",[t("p",[n._v("protected : 保护类型  在类里面, 子类里面可以访问, 在类外部无法访问")])]),n._v(" "),t("li",[t("p",[n._v("private : 私有 在类里面可以访问, 子类, 类外部都无法访问")])])]),n._v(" "),t("p",[n._v("属性没写名修饰符, 则默认是public")]),n._v(" "),t("h4",{attrs:{id:"静态属性-静态方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态属性-静态方法"}},[n._v("#")]),n._v(" 静态属性  静态方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Person {\n  static sex="男"\n  public name: string;\n  contructor(name: string) {\n    this.name = name\n  }\n\n  run(){\n    //实例 方法\n  }\n\n  static print() {\n    //静态方法   \n    // this.name  不能调用类里面的(实例)属性\n    // Person.sex  可以调用静态属性\n  }\n}\n')])])]),t("h4",{attrs:{id:"多态-与其它语言不一样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态-与其它语言不一样"}},[n._v("#")]),n._v(" 多态 (与其它语言不一样)")]),n._v(" "),t("p",[n._v("父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现,")]),n._v(" "),t("p",[n._v("多态属于继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Animal {\n  name: string;\n  construnctor(name:string) {\n    this.name = name\n  }\n  eat() {\n    conosle.log('吃的方法')\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  eat(){   //具体吃什么, 不知道,  由继承它的子类去实现,每一个子类的表现不一样\n    return this.name + '吃肉';\n  }\n}\n\nclass Cat extends Animal {\n  contructor(name: string){\n    super(name)\n  }\n  eat(){\n    return this.name + '吃老鼠';\n  }\n}\n")])])]),t("h4",{attrs:{id:"抽象类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[n._v("#")]),n._v(" 抽象类")]),n._v(" "),t("p",[n._v("抽象类,它是提供其它类继承的基类, 不能直接被实例化.")]),n._v(" "),t("p",[n._v("用abstract关键字定义抽象类和抽象方法, 抽象类中的抽象方法不包含具体的实现")]),n._v(" "),t("p",[n._v("抽象方法只能放在抽象类里面")]),n._v(" "),t("p",[n._v("抽象类和抽象方法用来定义标准, 继续它的子类必须实现抽象方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("abstract class Animal {\n  abstract eat():any;\n}\n// 这个抽象能不能实例化\n\nclass Dog extends Animal {\n  construnctor(){\n\n  }\n  eat() {\n    // 实现抽象类的方法\n  }\n}\n\n")])])]),t("h4",{attrs:{id:"接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[n._v("#")]),n._v(" 接口")]),n._v(" "),t("p",[n._v("接口的作用: 在面向对象的编程中, 接口是一种规范定义, 它定义了行为和动作的规范,在程序设\n计里,接口起到一种限制规范的作用. 接口只定义规范,不关心具体的实现.ts中的接口类似java\n同时还增加了更灵活的接口类型,包括属性,函数,可索引和类等.")]),n._v(" "),t("p",[t("strong",[n._v("属性接口")]),n._v(" 对json的约束")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\ninterface FullName {\n  firstName: string;\n  secondName?: string;  // ? 表示可选\n}\n\nfunction printName(name: FullName) {\n\n}\n\nprintName({\n  firstName: 'chen',\n  secondName: 'Kevin',    //这样写,必须和 interface 定义的一样\n})\n\nvar obj = {\n  age: 20,\n  firstName: 'chen',\n  secondName: '三'\n}\nprintName(obj)     //传入的参数必须包含 firstName 和 secondName\n")])])]),t("p",[t("strong",[n._v("函数类型接口")]),n._v(" 对方法传入的参数 以及返回值进行约束")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("interface encrypt {\n  (key:string, value: string):string;\n}\n\nvar md5:encrypt = function(key:string, value:string): string {\n\n}\n\n//另一种定义函数\nvar md5: (key:string, value:string) => string = function(key:string, value:string): string {\n\n}\n")])])]),t("p",[t("strong",[n._v("可索引接口,数组,对象的约束  (不常用)")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 定义数组的方式\nvar arr: number[] = [2342, 235]\nvar arr1: Array<string> = ['aaa', '222']\n\n\n//对数组的约束\ninterface UserArr {\n  [index:number]:string    //索引是number  值是 string\n}\n\nvar arr: UserArr = ['aaa', 'bbb']\n\n\n// 可索引接口, 对对象的约束\n\ninterface UserObj {\n  [index:string]:string\n}\n\nvar arr:UserObj = {name: '张三'}\n\n\n// 类类型接口: 对类的约束 和 抽象类的点相似\n\ninterface Animal {\n  name: string;\n  eat(str:string): void;\n}\n\nclass Dog implements Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  eat() {\n    console.log('xxxx');\n  }\n}\n")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);