(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{337:function(e,t,a){"use strict";a.r(t);var s=a(33),r=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[e._v("#")]),e._v(" 基础")]),e._v(" "),a("h2",{attrs:{id:"开启项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#开启项目"}},[e._v("#")]),e._v(" 开启项目")]),e._v(" "),a("h4",{attrs:{id:"安装django"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装django"}},[e._v("#")]),e._v(" 安装Django")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("> pip3 install django\n")])])]),a("h4",{attrs:{id:"创建一个django-project"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建一个django-project"}},[e._v("#")]),e._v(" 创建一个django project")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("> django-admin.py startproject mysite\n")])])]),a("p",[a("strong",[e._v("mysite目录结构")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("|-- mysite\n    |-- manage.py\n    |-- mysite            \n        |-- __init__.py\n        |-- settings.py\n        |-- urls.py\n        |-- wsgi.py\n")])])]),a("ul",[a("li",[e._v("里的mysite 与 外面的mysite 名字可以不相同,默认创建是相同的,里面的mysit是和整个项目相关的")]),e._v(" "),a("li",[e._v("manage.py :　Django项目里面的工具, 通过它可以调用django shell 和 数据库")]),e._v(" "),a("li",[e._v("settings.py :　包含了项目的默认设置,包括数据库信息,调试标志及其他一些工作变量")]),e._v(" "),a("li",[e._v("urls.py :　负责把url模式映射到应用程序\n1.15 06分")])]),e._v(" "),a("h4",{attrs:{id:"创建一个应用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建一个应用"}},[e._v("#")]),e._v(" 创建一个应用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("> python manage.py startapp blog\n\n|-- mysite\n    |-- blog\n        |-- migrations\n        |-- __init__.py\n        |-- admin.py\n        |-- apps.py\n        |-- models.py\n        |-- tests.py\n        |-- views.py\n    |-- manage.py\n    |-- mysite            \n        |-- __init__.py\n        |-- settings.py\n        |-- urls.py\n        |-- wsgi.py\n\n")])])]),a("ul",[a("li",[e._v("blog 文件是和应用相关的东西")]),e._v(" "),a("li",[e._v("models.py 模型")]),e._v(" "),a("li",[e._v("views.py 视图函数")])]),e._v(" "),a("h4",{attrs:{id:"新建视图文件夹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新建视图文件夹"}},[e._v("#")]),e._v(" 新建视图文件夹")]),e._v(" "),a("p",[e._v("手动在根目录下创建一个 templates 文件夹, 根据应用再创建相应的文件夹")]),e._v(" "),a("p",[e._v("并在 项目 settings.py TEMPLATES.DIRS 下添加目录")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("TEMPLATES = [\n    {\n        'BACKEND': 'django.template.backends.django.DjangoTemplates',\n        'DIRS': ['templates'],                    \n        'APP_DIRS': True,\n        'OPTIONS': {\n            'context_processors': [\n                'django.template.context_processors.debug',\n                'django.template.context_processors.request',\n                'django.contrib.auth.context_processors.auth',\n                'django.contrib.messages.context_processors.messages',\n            ],\n        },\n    },\n]\n")])])]),a("h4",{attrs:{id:"mtv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#mtv"}},[e._v("#")]),e._v(" MTV")]),e._v(" "),a("p",[e._v("http请求后, 由 项目的 urls.py 分配 视图函数 views,   views 或与models 联系, 然后, 调用 templates 下相应的模板")]),e._v(" "),a("h4",{attrs:{id:"启动项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启动项目"}},[e._v("#")]),e._v(" 启动项目")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("> python manage.py runserver 8888\n")])])]),a("ul",[a("li",[e._v("8888 是端口号, 不填,默认是8000")]),e._v(" "),a("li",[e._v("会默认生成一个 db.sqlite3  数据库存相关")])]),e._v(" "),a("h2",{attrs:{id:"静态文件配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态文件配置"}},[e._v("#")]),e._v(" 静态文件配置")]),e._v(" "),a("p",[e._v("在项目根目录 新建 static 文件夹 , 并找到 项目 settings.py")]),e._v(" "),a("p",[e._v("把路径添加上去")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 这个是原有的代码            这个是 将在模板引用时 的 url 如: /static/jQuery.js\nSTATIC_URL = \'/static/\'\n\n// 这个手动添加的代码\nSTATICFILES_DIRS = [\n    os.path.join(BASE_DIR, "static")    // "static" 新建的静态文件目录, 可以随便起名\n]\n\n//这样写,  STATIC_URL 这个不要动, \n// 实际目录,手动添加的可以随便动\n')])])]),a("h2",{attrs:{id:"路由控制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由控制"}},[e._v("#")]),e._v(" 路由控制")]),e._v(" "),a("p",[e._v("在urlps.py 里配置路由,  2.0 支持 path写法, 也支持 1.0的re_path写法")]),e._v(" "),a("h4",{attrs:{id:"简单的路由配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单的路由配置"}},[e._v("#")]),e._v(" 简单的路由配置")]),e._v(" "),a("p",[e._v("urls.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("urlpatterns = [\n    path('admin/', admin.site.urls),\n    path('timer/', views.timer),\n\n    # 路由配置:　　路径　　－－－－－－－＞　视图函数\n    # 从上到下 匹配, 如果匹配了就不往下走了\n    re_path(r'^articles/2003/$', views.specical_case_2003),\n    # 这里正则匹配上了,就调用,后面的函数,并传一个请求对象做参数request,\n    # 它有所有的请求信息, 一定要写,不管你用不用\n     re_path(r'^articles/([0-9]{4})/$', views.year_archive),\n     # 括号正则分组, 匹配到时, 会把它 作为request之后的第二个参数传入\n     # 位置参数,你可以自已随便用个参数接收它\n     re_path(r'^articles/([0-9]{4})/([0-9]{2})/$', views.month_archive),\n     \n     # 要从url中捕获一个值, 只需要在它周围放置一对圆括号\n     # 不需要添加一个前导反斜杠\n     # 每个正则表达式前面的'r' 是可选的, 建议加上\n]\n")])])]),a("p",[e._v("views.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from django.shortcuts import render, HttpResponse\n\ndef specical_case_2003(request):\n\n    return HttpResponse(\"111\")\n\ndef year_archive(request, year):\n\n    return HttpResponse(year)\n\ndef month_archive(request, year, month):\n\n    return HttpResponse(year + '--' + month)\n")])])]),a("h4",{attrs:{id:"有名分组"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有名分组"}},[e._v("#")]),e._v(" 有名分组")]),e._v(" "),a("p",[e._v("上面的 分组是没有名字的, 靠位置参数 获得值,也可以给它起个命名")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("# urls.py\nre_path(r'^articles/(?P<y>[0-9]{4})/(?P<m>[0-9]{2})/$', views.month_archive),\n\n# views.py\ndef month_archive(request, y, m):\n    # 这里就必须用 y, m 来接收了, 因为它是关键字传参, 谁先谁后就无所谓了\n    # y, m 数据类型  是字符串,   \n    # urls 传过来的都是字符串, 如果想要像数字那样去处理 需要转类型, path定义的urls则解决这个问题\n    return HttpResponse(year)\n")])])]),a("h4",{attrs:{id:"路由分发"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由分发"}},[e._v("#")]),e._v(" 路由分发")]),e._v(" "),a("p",[e._v("路由应该 每个应用写一个urls.py  然后, 由项目的urls.py 去做分发")]),e._v(" "),a("p",[e._v("可以在每个应用 下创建一个 urls.py")]),e._v(" "),a("p",[e._v("blog 应用下创建 urls.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from django.contrib import admin\nfrom django.urls import path, re_path\nfrom blog import views\n\nurlpatterns = [\n    re_path(r'^articles/2003/$', views.specical_case_2003),\n    re_path(r'^articles/([0-9]{4})/$', views.year_archive),\n    re_path(r'^articles/(?P<y>[0-9]{4})/(?P<m>[0-9]{2})/$', views.month_archive),\n]\n")])])]),a("p",[e._v("在项目urls.py下做分发")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from django.contrib import admin\nfrom django.urls import path, re_path, include\n\n\n# 需要先引入include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n\n    # 分发:\n    re_path(r'blog/', include(\"blog.urls\")),\n    # re_path(r'^', include(\"blog.urls\")),  这样也可以的,这各之前写的没分发一样了\n]\n")])])]),a("p",[e._v("现在是这样访问:　http://localhost:8080/blog/articles/2076/80/\n当匹配到 blog 就被分发到 blog下的 urls 下去处理剩下的路由(articles/2076/80/)")]),e._v(" "),a("h4",{attrs:{id:"密码登录示例"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#密码登录示例"}},[e._v("#")]),e._v(" 密码登录示例")]),e._v(" "),a("p",[e._v("注意先关闭一下 csrf   在项目 设置里的 中间件字段")]),e._v(" "),a("p",[e._v("url.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("re_path(r'^login/$', views.login)\n\n")])])]),a("p",[e._v("前端html")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('    // action 不写,就表示 提交到当前也  \n    // 如果以 / 开头,则是 表示当前域名加端口后, 再加上之后的路径\n    <form action="http://127.0.0.1:8000/blog/login/" method="POST">\n        用户名 <input type="text" name="user">\n        密码 <input type="password" name="pwd">\n        <input type="submit" value="submit">\n    </form>\n')])])]),a("p",[e._v("views.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("def login(request):\n    // 通过 请求方法的判断  然后 做出不同的响应\n    if request.method == 'GET':\n        return render(request, 'blog/login.html')\n    \n    else: \n        user = request.POST.get('user')\n        pwd = request.POST.get('pwd')\n\n        if user == 'yycu' and pwd == '123456':\n            return HttpResponse(\"登录成功\")\n        else:\n            return HttpResponse(\"密码或账号错误\")\n")])])]),a("h4",{attrs:{id:"路由反向解析-命名路由"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由反向解析-命名路由"}},[e._v("#")]),e._v(" 路由反向解析  --  命名路由")]),e._v(" "),a("p",[e._v("路由是一个可能随时被改的东西, 一但改了,其它地方也得改, 相当麻烦.\n可以在定义路由是传入一个关键字参灵敏 name='yourURLname'")]),e._v(" "),a("p",[e._v("urls.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("re_path(r'^login/$', views.login, name='login'),\n\n")])])]),a("p",[e._v("html这样用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" <form action=\"{% url 'login' %}\" method=\"POST\">\n\n //这里为什么样呢?\n // 因为在 渲染这个页面时, render时, {% url 'login' %}  模板语法,会被解析为相应的url\n // 它会先在 项目里的 urls.py 里找 ,然后找不到 再到 应用里的找\n")])])]),a("p",[e._v("在视图函数使用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from django.urls import reverse\n\ndef viewFunction(request):\n\n    url = reverse('url_name')\n    // 拿到后,就可以使用了\n    // 如果解析出来,含有 正则表达式, 可以第二个参数去替换,不然后报找不到\n    // url = reverse('year', args=(2003,))      \n    // 元组中有一个元素的写法是(元素,),  不然会被当做 (元素)  就不是元组了\n")])])]),a("h4",{attrs:{id:"路由名称空间-命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#路由名称空间-命名空间"}},[e._v("#")]),e._v(" 路由名称空间(命名空间)")]),e._v(" "),a("p",[e._v("多个应用, 对路由进行命名, 很大概率会出现重复命名的情况, 发生覆盖现象.")]),e._v(" "),a("p",[e._v("可以用名称空间来解决, 在路由分发时使用")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('// 在项目urls.py 引入各应用urls.py 时, 通过关键字参数 namespace 指定一个命名空间\n// re_path(r\'blog/\', include(("blog.urls", "namespace"))),   要用元组来传\nre_path(r\'blog/\', include(("blog.urls", "blog"))),\n\n')])])]),a("p",[e._v("开启了名称空间后,  以后 reverse 时 需要这样")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("reverse('namespace:name')        // 注意语法 :\nreverse('blog:name')   \n")])])]),a("h4",{attrs:{id:"path-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#path-方法"}},[e._v("#")]),e._v(" path 方法")]),e._v(" "),a("p",[e._v("django2.0 新增的path 方法")]),e._v(" "),a("ul",[a("li",[e._v('原先1.0版本的, re_path  传过来的路由参数, 都是字符串,即使 是数字,其实也是 "11123" 其实也是一个数字字符串')]),e._v(" "),a("li",[e._v("正则有可以能重复也同样的正则多次")])]),e._v(" "),a("p",[e._v("path 方法")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("urlpatterns = [\n    path('articles/2003/', views.special_case_2003),\n    path('articles/<int:year>/', views.year_archive),\n    path('articles/<int:year>/<int:month>', views.special_case_2003),\n    path('articles/<int:year>/<int:month>/<slug>', views.article_detail),\n]\n// 使用 <>    从url 中捕获值\n// 这里的int 是django 提供的一个转化器类型, 没写就是得到的是字符串\n// : 后时 参数名,  没有用int: 则<argname>   <>里的内容 是参数名\n// 转换器有:\n// str     捕获的都是 字符串   默认的\n// int     匹配正整数, 包含0\n// slug    匹配字母,数字及横杠,下划线组成的字符串\n// uuid    匹配格式化的uuid 如: 075194d3-6775-478e-a8a8-6c931e288f00\n// path    匹配任何非空字符串, 包含了路径分隔符    \n")])])]),a("p",[e._v("自定义转换器")]),e._v(" "),a("p",[e._v("// 在 app/urlconver.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("class MonConvert: \n\n    regex = \"[0-9]{2}\"   // 固定属性, 一定要这样的属性\n\n    def to_python(self, value):\n        return int(value)\n    \n    def to_url(self, value):    # 反向解析\n        return '%04d' % value\n")])])]),a("p",[e._v("使用转换器")]),e._v(" "),a("p",[e._v("在项目的 urls.py")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from django.urls import register_converter    //需要引入转换器注册函数\nfrom app.urlconver import MonConvert\n\n// 先注册                         别名是必须的\nregister_converter(MonConvert, '起个别名方便使用k:mm')\n\n path('articles/<mm:month>/', views.month_archive),\n")])])]),a("p",[e._v("**django1.0版本都是用 url来定义了, 只要把re_path换成url  其它都是一样的")]),e._v(" "),a("h2",{attrs:{id:"视图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#视图"}},[e._v("#")]),e._v(" 视图")]),e._v(" "),a("p",[e._v("一个视图函数, 简称视图,是一个简单的python函数,它接受web请求并返回web响应. 它一定要有一个返回值.")]),e._v(" "),a("h4",{attrs:{id:"request"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#request"}},[e._v("#")]),e._v(" request")]),e._v(" "),a("ul",[a("li",[e._v("request.method  请求方式")]),e._v(" "),a("li",[e._v("request.GET     get请求的数据   是一个字典   通过 get('key')  取值")]),e._v(" "),a("li",[e._v("request.POST    post请求的数据  是一个字典   通过 get('key')  取值")]),e._v(" "),a("li",[e._v("request.path    路径,  不包含 协议,域名,端口号,数据")]),e._v(" "),a("li",[e._v("request.get_full_path() 路径和数据  不包含 协议,域名,端口号")])]),e._v(" "),a("p",[e._v("还有很多.....")]),e._v(" "),a("h4",{attrs:{id:"respone"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#respone"}},[e._v("#")]),e._v(" respone")]),e._v(" "),a("p",[e._v("视图函数,返回的 就是response")]),e._v(" "),a("ul",[a("li",[e._v("return HttpResponse('字符串')")]),e._v(" "),a("li",[e._v("return render(request, 'html文件', [数据]); 数据是一个字典")])]),e._v(" "),a("h2",{attrs:{id:"模板"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板"}},[e._v("#")]),e._v(" 模板")]),e._v(" "),a("h4",{attrs:{id:"模板语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#模板语法"}},[e._v("#")]),e._v(" 模板语法")]),e._v(" "),a("p",[e._v("1.32")])])}),[],!1,null,null,null);t.default=r.exports}}]);