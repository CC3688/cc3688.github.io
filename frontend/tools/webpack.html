<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>webpack | CC3688 blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    
    <meta name="description" content="Just playing around">
    <link rel="preload" href="/assets/css/0.styles.1b5c6595.css" as="style"><link rel="preload" href="/assets/js/app.a761fdad.js" as="script"><link rel="preload" href="/assets/js/2.f625eefe.js" as="script"><link rel="preload" href="/assets/js/38.d197d8d0.js" as="script"><link rel="prefetch" href="/assets/js/10.9276f3bc.js"><link rel="prefetch" href="/assets/js/11.b682676a.js"><link rel="prefetch" href="/assets/js/12.e93f1a58.js"><link rel="prefetch" href="/assets/js/13.c670705b.js"><link rel="prefetch" href="/assets/js/14.3afc9644.js"><link rel="prefetch" href="/assets/js/15.ce0ec2af.js"><link rel="prefetch" href="/assets/js/16.0c8fed25.js"><link rel="prefetch" href="/assets/js/17.70f271e7.js"><link rel="prefetch" href="/assets/js/18.325e0978.js"><link rel="prefetch" href="/assets/js/19.57d5157d.js"><link rel="prefetch" href="/assets/js/20.c4a7a36b.js"><link rel="prefetch" href="/assets/js/21.d185011b.js"><link rel="prefetch" href="/assets/js/22.b6cd295c.js"><link rel="prefetch" href="/assets/js/23.077bd992.js"><link rel="prefetch" href="/assets/js/24.241b12cb.js"><link rel="prefetch" href="/assets/js/25.f8d57d84.js"><link rel="prefetch" href="/assets/js/26.2ca22227.js"><link rel="prefetch" href="/assets/js/27.e11e823c.js"><link rel="prefetch" href="/assets/js/28.50281ac8.js"><link rel="prefetch" href="/assets/js/29.1fce1f13.js"><link rel="prefetch" href="/assets/js/3.48bf621d.js"><link rel="prefetch" href="/assets/js/30.9c96825f.js"><link rel="prefetch" href="/assets/js/31.12c3998e.js"><link rel="prefetch" href="/assets/js/32.fb94fa3c.js"><link rel="prefetch" href="/assets/js/33.bd9b462f.js"><link rel="prefetch" href="/assets/js/34.58ac7858.js"><link rel="prefetch" href="/assets/js/35.b55b61d6.js"><link rel="prefetch" href="/assets/js/36.245f58ef.js"><link rel="prefetch" href="/assets/js/37.d025f029.js"><link rel="prefetch" href="/assets/js/39.b7e1ce60.js"><link rel="prefetch" href="/assets/js/4.97b1d945.js"><link rel="prefetch" href="/assets/js/40.0c1a84a9.js"><link rel="prefetch" href="/assets/js/41.d4afa780.js"><link rel="prefetch" href="/assets/js/42.121cbf6d.js"><link rel="prefetch" href="/assets/js/43.0479770a.js"><link rel="prefetch" href="/assets/js/44.d7c52248.js"><link rel="prefetch" href="/assets/js/45.d1b8ece5.js"><link rel="prefetch" href="/assets/js/46.0da90371.js"><link rel="prefetch" href="/assets/js/47.3ba8bcd7.js"><link rel="prefetch" href="/assets/js/48.b2dc0303.js"><link rel="prefetch" href="/assets/js/49.61cc678b.js"><link rel="prefetch" href="/assets/js/5.63cb3433.js"><link rel="prefetch" href="/assets/js/50.712e3a95.js"><link rel="prefetch" href="/assets/js/51.3e671530.js"><link rel="prefetch" href="/assets/js/6.345a20a1.js"><link rel="prefetch" href="/assets/js/7.57211556.js"><link rel="prefetch" href="/assets/js/8.e8f7270a.js"><link rel="prefetch" href="/assets/js/9.68af55ab.js">
    <link rel="stylesheet" href="/assets/css/0.styles.1b5c6595.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">CC3688 blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/JS/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/TS/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/tools/" class="nav-link router-link-active">
  tools
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backend/Node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/backend/PHP/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/backend/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/backend/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/framework/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/framework/Adonis/" class="nav-link">
  Adonis
</a></li><li class="dropdown-item"><!----> <a href="/framework/Laravel/" class="nav-link">
  Laravel
</a></li><li class="dropdown-item"><!----> <a href="/framework/Django/" class="nav-link">
  Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="移动" class="dropdown-title"><span class="title">移动</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mobile/小程序/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/mobile/RN/" class="nav-link">
  RN
</a></li><li class="dropdown-item"><!----> <a href="/mobile/Flutter/" class="nav-link">
  Flutter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/jingguan/" class="nav-link">
  经管
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/frontend/JS/" class="nav-link">
  JS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/TS/" class="nav-link">
  TS
</a></li><li class="dropdown-item"><!----> <a href="/frontend/tools/" class="nav-link router-link-active">
  tools
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><span class="title">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/backend/Node/" class="nav-link">
  Node
</a></li><li class="dropdown-item"><!----> <a href="/backend/PHP/" class="nav-link">
  PHP
</a></li><li class="dropdown-item"><!----> <a href="/backend/Python/" class="nav-link">
  Python
</a></li><li class="dropdown-item"><!----> <a href="/backend/MySQL/" class="nav-link">
  MySQL
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/framework/Vue/" class="nav-link">
  Vue
</a></li><li class="dropdown-item"><!----> <a href="/framework/React/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/framework/Adonis/" class="nav-link">
  Adonis
</a></li><li class="dropdown-item"><!----> <a href="/framework/Laravel/" class="nav-link">
  Laravel
</a></li><li class="dropdown-item"><!----> <a href="/framework/Django/" class="nav-link">
  Django
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="移动" class="dropdown-title"><span class="title">移动</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mobile/小程序/" class="nav-link">
  小程序
</a></li><li class="dropdown-item"><!----> <a href="/mobile/RN/" class="nav-link">
  RN
</a></li><li class="dropdown-item"><!----> <a href="/mobile/Flutter/" class="nav-link">
  Flutter
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/other/jingguan/" class="nav-link">
  经管
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/frontend/tools/" class="sidebar-link">tools</a></li><li><a href="/frontend/tools/webpack.html" class="active sidebar-link">webpack</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#js模块化" class="sidebar-link">JS模块化</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#css-模块化" class="sidebar-link">CSS 模块化</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#核心概念" class="sidebar-link">核心概念</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#编译-es6-7" class="sidebar-link">编译 ES6/7</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#编译-typescript" class="sidebar-link">编译 typescript</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#提取公共代码" class="sidebar-link">提取公共代码</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#懒加载" class="sidebar-link">懒加载</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#处理css" class="sidebar-link">处理css</a></li><li class="sidebar-sub-header"><a href="/frontend/tools/webpack.html#安装-webpack" class="sidebar-link">安装 webpack</a></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h1> <h2 id="js模块化"><a href="#js模块化" class="header-anchor">#</a> JS模块化</h2> <h3 id="命名空间"><a href="#命名空间" class="header-anchor">#</a> 命名空间</h3> <p>库名.类别名.方法名</p> <div class="language- extra-class"><pre class="language-text"><code>const NameSpace = {}   // 一个命名空间

//如果被定义就用原来的,如果没有就用 {} 避免被重复覆盖
NameSpace.type = NameSpace.type || {}      // type 命名空间

NameSpace.type.method = function() {     // type 命名空间的 方法

}
</code></pre></div><p>不足: 名字长, 使用需要 点点点   (object . 语法)</p> <h3 id="commonjs"><a href="#commonjs" class="header-anchor">#</a> commonjs</h3> <p>一个文件为一个模块</p> <p>通过 module.exports 暴露模块接口</p> <p>通过 require 引入模块</p> <p>同步执行</p> <h3 id="amd-cmd-umd"><a href="#amd-cmd-umd" class="header-anchor">#</a> AMD/CMD/UMD</h3> <h4 id="amd"><a href="#amd" class="header-anchor">#</a> AMD</h4> <p>Async Module Definition</p> <p>使用 define 定义模块</p> <p>使用 require 加载模块</p> <p>RequireJS (代表库)</p> <p>依赖前置, 提前执行</p> <div class="language- extra-class"><pre class="language-text"><code>define(
  &quot;alpha&quot;, //模块名 可省略
  [&quot;require&quot;, &quot;exports&quot;, &quot;beta&quot;], //依赖
  function(require, exports, beta) {   
    //参数声明的模块,有没有用到,都会提前执行, 参数的模块与上面依赖声明的模块一一对应
    exports.verb = function(){  // 模块输出
      return beta.verb()
    }
  }
)
</code></pre></div><h4 id="cmd"><a href="#cmd" class="header-anchor">#</a> CMD</h4> <p>common module definition</p> <p>一个文件为一个模块</p> <p>使用 define 来定义一个模块</p> <p>使用 require 来加载一个模块</p> <p>SeaJS(代表库)</p> <p>特点, 尽可能懒执行, 这也是 和 AMD的最大不同, AMD把所有的依赖前置了,先执行了依赖的代码.</p> <div class="language- extra-class"><pre class="language-text"><code>// 所有模块 都通过 define 来定义
define(function(require, exports, module){
  // 通过 require 引入依赖
  var $ = require('jquery');
  var Spinnig = require('./spinnig);

  // 通过 exports 对外提供接口
  exports.doSometing = ...

  // 或者通过 module.exports 提供整个接口
  module.exports = ...

  //exports =  ...  不能这样做, 会覆盖掉这个参数
});

</code></pre></div><h4 id="umd"><a href="#umd" class="header-anchor">#</a> UMD</h4> <p>universal module definition</p> <p>通用解决方案</p> <p>三个步奏:</p> <p>1 判断是否支持 AMD</p> <p>2 判断是否支持 commonJS</p> <p>3 如果都没有  使用全局变量</p> <div class="language- extra-class"><pre class="language-text"><code>(function(root, factory){

  if(type define === 'function' &amp;&amp; define.amd) {

    define([], factory);

  } else if(typeof exports === 'object') {

    module.exports = factory()

  } else {

    root.returnExprots = factory()

  }
})(this, function(){

  return {}
})


</code></pre></div><h3 id="es6-module-esm"><a href="#es6-module-esm" class="header-anchor">#</a> ES6 module   / ESM</h3> <p>EcmaScript Module
一个文件 一个模块
export 暴露
import 引用</p> <div class="language- extra-class"><pre class="language-text"><code>// 引入
import theDefault, { named1, named2 } from 'src/mylib'
import theDefault from 'src/mylib'
import { named1, named2 } from 'src/mylib'

// 引入并重命名
import { named1 as myNamed1, named2 } from 'src/mylib'

// 引入所有属性 到一个 object  下方可通赤 mylib.xx 使用
import * as mylib from 'src/mylib

// 只加载模块, 不引入,   一般用来引入 css 文件
import 'src/mylib'

</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>export var myVar1 = ''
export let myVar2 = ''
export const MY_CONST = ''

export function myFunc() {}
export function* myGeneratorFunc() {}
export class MyClass {}


// export default 只能有一个, 下面展示是示例可以有这样的导出而已
export default 134

export default function(x) {
  return x
}

export defualt x =&gt; x

exportd default class {
  constructor(x, y) {
    this.x = x
    this.y = y
  }
}

// 也可以先定义 声明  export 出去
const MY_CONST = ''
function myFunc() {}
// 下面只是展示, 只能 导出  一个 {}   覆盖
export { MY_CONST, myFunc }
export { MY_CONST as THE_CONST, myFunc as tearFunc }
// 引入其它模块并在此模块导出
export * from 'src/other_module
export { foo, bar } from 'src/other_module
export { foo as myFoo, bar } from 'src/other_module'
</code></pre></div><h2 id="css-模块化"><a href="#css-模块化" class="header-anchor">#</a> CSS 模块化</h2> <p>css模块化 也就是css规范</p> <p>BEM 是众多规范的一种</p> <p><code>块（block）、元素（element）、修饰符（modifier），由 Yandex 团队提出的一种前端 CSS 命名方法论。</code></p> <p>- 中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。</p> <p>__ 双下划线：双下划线用来连接块和块的子元素</p> <p>_ 单下划线：单下划线用来描述一个块或者块的子元素的一种状态</p> <p>命名约定的模式是：</p> <div class="language- extra-class"><pre class="language-text"><code>.block {}

.block__element {}

.block--modifier {}
</code></pre></div><p>每一个块(block)名应该有一个命名空间（前缀）</p> <ul><li>block 代表了更高级别的抽象或组件。</li> <li>block__element 代表 .block 的后代，用于形成一个完整的 .block 的整体。</li> <li>block--modifier 代表 .block 的不同状态或不同版本。使用两个连字符和下划线而不是一个，是为了让你自己的块可以用单个连字符来界定</li></ul> <div class="language- extra-class"><pre class="language-text"><code>&lt;div class=&quot;article&quot;&gt;
    &lt;div class=&quot;article__body&quot;&gt;
        &lt;div class=&quot;tag&quot;&gt;&lt;/div&gt;
        &lt;button class=&quot;article__button--primary&quot;&gt;&lt;/button&gt;
        &lt;button class=&quot;article__button--success&quot;&gt;&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;

</code></pre></div><p>什么时候使用BEM ?</p> <ul><li>使用 BEM 的诀窍是，你要知道什么时候哪些东西是应该写成 BEM 格式的。</li> <li>并不是每个地方都应该使用 BEM 命名方式。当需要明确关联性的模块关系时，应当使用 BEM 格式。</li> <li>比如只是一条公共的单独的样式，就没有使用 BEM 格式的意义</li></ul> <p>BEM的不足就是会让名字长, 在less可以这样, 书写还是蛮方便的</p> <div class="language- extra-class"><pre class="language-text"><code>.article {
    max-width: 1200px;
    &amp;__body {
        padding: 20px;
    }
    &amp;__button {
        padding: 5px 8px;
        &amp;--primary {background: blue;}
        &amp;--success {background: green;}
    }
}

</code></pre></div><h2 id="核心概念"><a href="#核心概念" class="header-anchor">#</a> 核心概念</h2> <h3 id="entry"><a href="#entry" class="header-anchor">#</a> Entry</h3> <p>代码的入口,  也是打包的入口,  从入口进入,找依赖及找依赖的依赖. entry可以是一个入口,也可以是多个.</p> <div class="language- extra-class"><pre class="language-text"><code>// 三种入口的写法, 第三种比较好, 可以为打包后的文件起名字, key可以为chunk值
// 值为 一个可以找的文件的地址就可以
module.exports = {
  entry: 'index.js'
  entry: ['index.js', 'vendor.js']
  entry: {
    index: 'index.js'
  }
}
</code></pre></div><h3 id="output"><a href="#output" class="header-anchor">#</a> Output</h3> <p>打包生成的文件 bundle</p> <p>可以是一个或多个</p> <p>可以自定义规则</p> <p>配置要和entry对应</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  entry: 'index.js',
  output: {
    filename: 'index.mini.js'
  }
  entry: {
    index: 'index.js',
    vendor: 'vendor.js'
  },
  output: {    // name就是entry的key值
    filename: '[name].min.[hash:5].js'
  }
}
</code></pre></div><h3 id="loaders"><a href="#loaders" class="header-anchor">#</a> Loaders</h3> <p>处理文件</p> <p>转化为模块</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  module: {
    rules: [
      {
        test: /\.css$/,   // 正则
        use: 'css-loader' // 使用的loader
      }
    ]
  }
}
</code></pre></div><h3 id="plugins"><a href="#plugins" class="header-anchor">#</a> Plugins</h3> <p>参与打包整个过程</p> <p>打包优化和压缩</p> <p>配置编译时的变量</p> <p>极其灵活</p> <p>常用的Plugins:</p> <ul><li>优化相关</li></ul> <blockquote><p>CommonsChunkPlugin</p> <p>UglifyjsWebpackPlugin</p></blockquote> <ul><li>功能相关</li></ul> <blockquote><p>ExtractTextWebpackPlugin</p> <p>HtmlWebpackPlugin</p> <p>HotModuleReplacementPlugin</p> <p>CopyWebpackPlugin</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>const webpack = require('webpack')

module.exports = {
  // 是一个数组, 可以使用多个
  plugins: [
    new webpack.optimize.UglifyJsPlugin()
  ]
}

</code></pre></div><p><strong>常见名词</strong>
Chunk 代码块
Bundle 一束一捆, 被打包后的代码
Module 模块,通过loader处理后就是模块</p> <h2 id="编译-es6-7"><a href="#编译-es6-7" class="header-anchor">#</a> 编译 ES6/7</h2> <p>babel-loader (babel.io 官网   https://www.babeljs.cn/ 中文官网)</p> <p><strong>安装</strong></p> <p><code>npm install --save-dev babel-loader @babel/core</code></p> <p><strong>babel presets</strong></p> <p>babel presets 是规范的总结, 有:
es2015<br>
es2016<br>
es2017<br>
env(常用)<br>
babel-preset-react
babel-preset-state 0-3 (未发布的总结)</p> <p><strong>安装</strong></p> <p><code>npm install --save-dev @babel/preset-env</code></p> <p><strong>babel polyfill</strong></p> <p>全局垫片 (使各种浏览器环境一致/api一致)
会污染全局</p> <p>为应用准备的(就是我们自己开发的应用, 不是为了开发框架,如vue 准备的)</p> <p><code>npm install --save babel-polyfill</code></p> <div class="language- extra-class"><pre class="language-text"><code>//使用
import 'babel-polyfill'
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>// 在webpack.config.js 里的 module 里配置
  module: {
    rules: [
      {
        test: /\.js$/,
        //use: 'babel-loader',
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              [
                '@babel/preset-env', 
                {
                  targets: {
                    browsers: ['&gt;1%', 'last 2 versions']
                  }
                }
              ]
            ]
          }
        },
        exclude: '/node_modules/'
      }
    ]
  }
</code></pre></div><p><strong>babel runtime transform</strong></p> <p>局部垫片</p> <p>为开发框架准备</p> <p>不污染全局</p> <p><code>npm install --save-dev @babel/plugin-transform-runtime</code></p> <p><code>npm install --save @babel/runtime</code></p> <div class="language- extra-class"><pre class="language-text"><code>// 使用  配置   要 创建 一个babel的配置文件   .babelrc
{
  &quot;presets&quot;: [
    [
      &quot;@babel/preset-env&quot;, 
      {
        &quot;targets&quot;: {
          &quot;browsers&quot;: [&quot;&gt;1%&quot;, &quot;last 2 versions&quot;]
        }
      }
    ]
  ],
  &quot;plugins&quot;: [&quot;@babel/transform-runtime&quot;]
}
</code></pre></div><h2 id="编译-typescript"><a href="#编译-typescript" class="header-anchor">#</a> 编译 typescript</h2> <p>typscript 是微软出品的 Javascript的超集</p> <p><strong>安装</strong></p> <p><code>npm i -D typescript ts-loader</code></p> <p><code>npm i -D typescript awesome-typescript-loader //第三方法的</code></p> <p><strong>配置</strong> 文件</p> <p>tsconfig.json
'''
{
&quot;compilerOptions&quot;: {
&quot;module&quot;: &quot;commonjs&quot;,
&quot;target&quot;: &quot;es5&quot;,
&quot;allowJs&quot;: true,
&quot;typeRoots&quot;: [
&quot;./node_modules/@types&quot;,
&quot;./typings/modules&quot;
]
},
&quot;include&quot;: [
&quot;./src/*&quot;
],
&quot;exclude&quot;: [
&quot;./node_modules&quot;
]
}
'''</p> <p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = {
  mode: 'development',
  entry: {
    'app': './src/app.ts'
  },
  output: {
    filename: '[name].bundle.js'
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        use: {
          loader: 'ts-loader'
        }
      }
    ]
  }
}
</code></pre></div><p><strong>声明文件</strong></p> <p><code>npm i -S @types/lodash</code></p> <p><code>npm i -S install @types/vue</code>
这种需要自己去 安装 需要的 类库</p> <p><strong>Typings</strong></p> <p>全局安装, 可以多一个typings</p> <p><code>npm i -g typings</code></p> <p><code>typings install lodash</code></p> <h2 id="提取公共代码"><a href="#提取公共代码" class="header-anchor">#</a> 提取公共代码</h2> <p>CommonsChunkPlugin 提取公共代码块 (v3可以用, v4 已经废弃)</p> <div class="language- extra-class"><pre class="language-text"><code>const webpack = require('webpack')
const path = require('path')

module.exports = {
  entry: {
    'pageA': './src/pageA',
    'pageB': './src/pageB',
    'vendor': ['lodash']      // 多入口,才有效果,  单一入口用户代码分割  懒加载
  },

  output: {
    path: path.resolve(__dirname, './dist'),
    filename: '[name].bundle.js',
    chunkFilename: '[name].chunk.js'
  },

  plugins: [
    new webpack.optimize.CommonsChunkPlugin({
      name: 'common',
      minChunks: 2,
      chunks: ['pageA', 'pageB']
    }),
    new webpack.optimize.CommonsChunkPlugin({
      name: ['vendor', 'manifest'],
      minChunks: Infinity
    }),

  ]
}
</code></pre></div><h2 id="懒加载"><a href="#懒加载" class="header-anchor">#</a> 懒加载</h2> <p>import(</p> <p>/* webpackChunkName: async-chunk-name */</p> <p>/* webpackMode: lazy */</p> <p>modulename
)</p> <p>通过注释的方式, 来告诉webpack 一些额外的信息</p> <h2 id="处理css"><a href="#处理css" class="header-anchor">#</a> 处理css</h2> <p>引入</p> <p>css modules</p> <p>配置 less/sass</p> <p>提取 css 代码</p> <p>style-loader     //创建样式到你的 html 标签中</p> <p>css-loader       // 让你可以 import css 文件 到你的js中</p> <h2 id="安装-webpack"><a href="#安装-webpack" class="header-anchor">#</a> 安装 webpack</h2> <div class="language- extra-class"><pre class="language-text"><code>npm i -D webpack webpack-cli
</code></pre></div><p><strong>安装指定版本</strong></p> <div class="language- extra-class"><pre class="language-text"><code>npm info webpack    //查看webpack的历史发布信息

npm install webpack@x.xx  webpack-cli -D    //安装指定版本
</code></pre></div><h4 id="运行"><a href="#运行" class="header-anchor">#</a> 运行</h4> <p>在项目根目下运行</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; webpack -V            // 这个, 要全局安装,才能找到这个命令
&gt; npx webpack        // npx 是npm 提供的一个工具, 它会在当前根目录下的node_module 查找webpack 运行
</code></pre></div><ul><li>webpack 支持零配置,运行上述命令</li> <li>默认以scr/index.js为入口文件</li> <li>默认dist/main.js为打包后的文件</li></ul> <h4 id="配置文件"><a href="#配置文件" class="header-anchor">#</a> 配置文件</h4> <p>默认配置文件是 webpack.config.js, 运行webpack会自动加载它.
如果使用它的名字,则需要指定配置文件名</p> <div class="language- extra-class"><pre class="language-text"><code>npx webpack     // 执行命令后会自己加载黑夜的配置文件,并使用执行

npx webpack --config webpackcofnig.js  //通过 --config 配置指定配置文件 webpackcofnig.js
</code></pre></div><p>配置文件是common.js规范</p> <p>webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require(&quot;path&quot;)

module.exports = {
  mode: &quot;development&quot;,    //development  production
  // 入口文件配置 string | array | object
  entry: {
    index:  &quot;./src/index.js&quot;
  },

  //出口
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),  // 必须是绝对路径
    filename: &quot;[name].js&quot;     //[name]  占位符,原来文件叫什么名就叫什么名, 即入口要用object的形式, name 就是对应入口文件的key 
    //publicPath: &quot;https:/www.cdn.com&quot;  // 打包后的文件 以它为前缀,为打包后的文件加路径
  }
}
</code></pre></div><h4 id="在package-json运行-脚本命令"><a href="#在package-json运行-脚本命令" class="header-anchor">#</a> 在package.json运行  脚本命令</h4> <p>在package.json里的scripts里指定</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;webpack&quot;
}
</code></pre></div><p>然后就可以通过npm run dev 运行了</p> <h4 id="loader"><a href="#loader" class="header-anchor">#</a> loader</h4> <p>模块转换器, 用于把模块原内容按照需求转换成新的内容</p> <p>webpack是模块打包工具, 而模块不仅仅是js, 还可以是css 图片或者其它格式</p> <p>webpack默认只知道如何处理js模块, 其它格式的模块处理,就需要loader了</p> <h4 id="moudle"><a href="#moudle" class="header-anchor">#</a> moudle</h4> <p>一切皆模块, 一个模块对应一个文件, webpack会从配置的entry开始递归找出所有依赖的模块</p> <h5 id="file-loader"><a href="#file-loader" class="header-anchor">#</a> file-loader</h5> <p>把打包入口中识别的资源模块,移到到输出目录, 并返回一个地址名称</p> <p>当我们需要模块,仅是从源代码挪移到打包目录,就可以用file-loader来处理</p> <p>txt, svg, csv, excel, 图片资源等等</p> <div class="language- extra-class"><pre class="language-text"><code> module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: &quot;file-loader&quot;,
          options: {
            name: &quot;[name]_[hash].[ext]&quot;,   // [name] 原文件名, [ext]原后缀 [hash]当前打包的版本号, 解决缓存,让用户可以第一时间更新内容
            outputPath: &quot;imgs/&quot;
          }
        }
      }
    ]
  }
</code></pre></div><h5 id="url-loader"><a href="#url-loader" class="header-anchor">#</a> url-loader</h5> <p>可以处理 file-loader的所有事情,但遇到jpg格式, 会把图片转换成base64格式字符串</p> <p>并打包到js里, 适合小体积图片, 不合适大图片</p> <div class="language- extra-class"><pre class="language-text"><code>module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: &quot;url-loader&quot;,
          options: {
            name: &quot;[name]_[hash].[ext]&quot;,   // [name] 原文件名, [ext]原后缀 [hash]当前打包的版本号, 解决缓存,让用户可以第一时间更新内容
            outputPath: &quot;imgs/&quot;,
            limit: 2048
          }
        }
      }
    ]
  }
</code></pre></div><h5 id="style-loader-css-laoder"><a href="#style-loader-css-laoder" class="header-anchor">#</a> style-loader css-laoder</h5> <div class="language- extra-class"><pre class="language-text"><code>{
  test: /\.css$/,
  use: [&quot;style-loader&quot;, &quot;css-loader&quot;]  //这两个laoder是有先后顺序的, 从后向前执行的,先 css-loader处理,再style-loader处理
  // 先用css-loader 识别是css进行处理，然后用style-loader把样式插入到html &lt;style&gt;...&lt;/style&gt;
  
}
</code></pre></div><h5 id="sass-loader-node-sass"><a href="#sass-loader-node-sass" class="header-anchor">#</a> sass-loader node-sass</h5> <div class="language- extra-class"><pre class="language-text"><code>      {
        test: /\.scss$/,
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;, &quot;sass-loader&quot;]  //这三个laoder是有先后顺序的, 从后向前执行的,先sass-loader处理, css-loader再处理,再style-loader最后处理
        
      }
</code></pre></div><h4 id="postcss-loader"><a href="#postcss-loader" class="header-anchor">#</a> postcss-loader</h4> <p>样式自动添加前缀, 它还需要再安装一个 autoprefixer  <code>npm i autoprefixer -D</code></p> <div class="language- extra-class"><pre class="language-text"><code>{
  test: /\.scss$/,
  use: [
      &quot;style-loader&quot;,
        &quot;css-loader&quot;, 
        { 
          loader: &quot;postcss-loader&quot;,
          options: {
            plugins: [ require(&quot;autoprefixer&quot;)]
          }
        },
        &quot;sass-loader&quot;]  
        //这三个laoder是有先后顺序的, 从后向前执行的,先sass-loader处理, css-loader再处理,再 .
        //style-loader最后处理, autoprefixer 可以写配置的方式引入
  

}
</code></pre></div><h4 id="plugins-2"><a href="#plugins-2" class="header-anchor">#</a> plugins</h4> <p><strong>module是webpack处理不认识的文件用的</strong> <strong>plugins是webpack处理过程中增加功能用的</strong>
webpack 带s 的字段 是用数组的形式</p> <div class="language- extra-class"><pre class="language-text"><code>plugins: [
  new htmlWebpackPlugin({
    title: &quot;我是首页&quot;,
    template: &quot;./index.html&quot;,
    //inject: true | 'head' | 'body' | false  注入所有的资源到特定的模板
    // true 或 body 插到body底, head 就插到 head元素中
    filename: &quot;index.html&quot;     //可以起名, 默认是 index.html
  })

  // options 通过传参进去{}
]
</code></pre></div><p>htmlWebpackPlugin 支持 ejs 模板语法, 上面的title 要到 template: &quot;./index.html&quot;,这样写</p> <div class="language- extra-class"><pre class="language-text"><code>&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
</code></pre></div><h5 id="配置多个入口文件"><a href="#配置多个入口文件" class="header-anchor">#</a> 配置多个入口文件</h5> <p>初步配置多入口文件</p> <div class="language- extra-class"><pre class="language-text"><code>const path = require(&quot;path&quot;)
const htmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;)


module.exports = {
  mode: &quot;development&quot;,
  // 入口文件配置 string | array | object
  entry: { 
      index: &quot;./src/index.js&quot;,
      list: &quot;./src/list.js&quot;,
      detail: &quot;./src/detail.js&quot;,
    },
  //出口
  output: {
    path: path.resolve(__dirname, &quot;dist&quot;),
    filename: &quot;[name].js&quot;       //[name]  占位符,原来文件叫什么名就叫什么名
                                // 入口,要用 object name是其key
  },

  module: {
    rules: [
      {
        test: /\.(png|jpe?g|gif)$/,
        use: {
          loader: &quot;url-loader&quot;,
          options: {
            name: &quot;[name]_[hash].[ext]&quot;,   // [name] 原文件名, [ext]原后缀 [hash]当前打包的版本号, 解决缓存,让用户可以第一时间更新内容
            outputPath: &quot;imgs/&quot;,
            limit: 2048
          }
        }
      },
      {
        test: /\.scss$/,
        use: [
            &quot;style-loader&quot;,
             &quot;css-loader&quot;, 
             { 
               loader: &quot;postcss-loader&quot;,
               options: {
                 plugins: [ require(&quot;autoprefixer&quot;)]
               }
              },
             &quot;sass-loader&quot;]  
             //这三个laoder是有先后顺序的, 从后向前执行的,先sass-loader处理, css-loader再处理,再style-loader最后处理
        
      }
    ]
  },
  plugins: [
    new htmlWebpackPlugin({
      title: &quot;我是首页&quot;,
      template: &quot;./index.html&quot;,
      filename: &quot;index.html&quot;,   
      chunks: [&quot;index&quot;]       // chunks 打包后的文件   这样配置,就 index.html 下只引入index.js
    }),
    new htmlWebpackPlugin({
      title: &quot;我list&quot;,
      template: &quot;./index.html&quot;,
      filename: &quot;list.html&quot;,
      chunks: [&quot;list&quot;]       // chunks 打包后的文件   这样配置,就 list.html 下只引入list.js
    }),
    new htmlWebpackPlugin({
      title: &quot;我是detail&quot;,
      template: &quot;./index.html&quot;,
      filename: &quot;detail.html&quot;,
      chunks: [&quot;detail&quot;]     // chunks 打包后的文件   这样配置,就 detail.html 下只引入detail.js
    }),
  ]

}
</code></pre></div><h5 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="header-anchor">#</a> clean-webpack-plugin</h5> <p>打包时删除旧的文件, 默认是dist目录, 其它路径要自己配置</p> <div class="language- extra-class"><pre class="language-text"><code>const {CleanWebpackPlugin} = require(&quot;clean-webpack-plugin&quot;)

plugins: [
    new CleanWebpackPlugin()
]

</code></pre></div><h5 id="min-css-extract-plugin"><a href="#min-css-extract-plugin" class="header-anchor">#</a> min-css-extract-plugin</h5> <p>把css代码抽出来成为单独的文件</p> <div class="language- extra-class"><pre class="language-text"><code>const MiniCssExtractPlugin  = require(&quot;mini-css-extract-plugin&quot;)

//module.rulses 
      {
        test: /\.scss$/,
        use: [
            MiniCssExtractPlugin.loader,
             &quot;css-loader&quot;, 
             { 
               loader: &quot;postcss-loader&quot;,
               options: {
                 plugins: [ require(&quot;autoprefixer&quot;)]
               }
              },
             &quot;sass-loader&quot;]  
             //这三个laoder是有先后顺序的, 从后向前执行的,先sass-loader处理, css-loader再处理,再style-loader最后处理
        
      }
//plugins
plugins: [
    new MiniCssExtractPlugin({
      filename: &quot;[name].css&quot;
    }),
  ]

</code></pre></div><p>多个css文件 会被 css-loader 合并为一个文件</p> <h5 id="sourcemap"><a href="#sourcemap" class="header-anchor">#</a> sourceMap</h5> <p>源代码与打包后的代码的映射关系</p> <p>在dev模式中,默认开启, 关闭的话,可以在配置文件里</p> <div class="language- extra-class"><pre class="language-text"><code>devtool: &quot;none&quot;   //关sourceMap 
devtool: &quot;cheap-module-eval-source-map&quot;, //开发环境配置
devtool: &quot;cheap-module-source-map&quot;, //线上生产环境配置
</code></pre></div><h5 id="webpack-dev-server"><a href="#webpack-dev-server" class="header-anchor">#</a> webpack-dev-server</h5> <p>开发服务器, 开启后会发现dist目录没有了, devServer把打包后的模块不放在dist目录下,</p> <p>而是放到内存中,从而提升速度</p> <p>然后我们开发时,可以在package.json 配置一个script命令,</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
  &quot;server&quot;: &quot;webpack-dev-server&quot;
}
</code></pre></div><p>在webpck.config.js配置</p> <div class="language- extra-class"><pre class="language-text"><code>// 增加一个字段
devServer: {
    contentBase: &quot;./dist&quot;,
    open: true,
    port: 8888, 
    proxy: {     // 开发时,可以在这里配置一下,解决跨域的问题
      &quot;/api&quot;: {
        target: &quot;http://localhost:9092&quot;,
      }
    }
  }
</code></pre></div><h5 id="hot-module-replacement-hmr-热模块替换"><a href="#hot-module-replacement-hmr-热模块替换" class="header-anchor">#</a> hot module replacement (HMR: 热模块替换)</h5> <p>开发过程中实现局部刷新,即开启 hmr</p> <div class="language- extra-class"><pre class="language-text"><code>const webpack = require(&quot;webpack&quot;)     //先引入webpack

plugins: [
  new webpack.HotModuleReplacementPlugin()  // 在插件里引入
],

devServer: {
    contentBase: &quot;./dist&quot;,
    open: true,
    port: 8888, 
    proxy: {     // 开发时,可以在这里配置一下,解决跨域的问题
      &quot;/api&quot;: {
        target: &quot;http://localhost:9092&quot;,
      }
    },
    hot: true    // 开启 hmr
    hotOnly: true  // 即便hmr不生效,浏览器也不自动刷新,就开启hotOnly
  }

</code></pre></div><p>各种框架需要使用社区提供的各种loader
如: react hot loader, vue loader ...</p> <h5 id="babel处理es6"><a href="#babel处理es6" class="header-anchor">#</a> babel处理ES6</h5> <p>需要安装</p> <div class="language- extra-class"><pre class="language-text"><code>npm i -D babel-loader @babel/core @babel/preset-env
</code></pre></div><ul><li>babel-loader 是webpack与babel的通信桥梁, @babel/preset-env负责把es6转成es5</li> <li>@babel/preset-env里包含了es6转es5的转换规则</li></ul> <p>@babel/preset-env 还不够, Promise等一些还是直接过来了, 需要借助@babel/polyfill</p> <p>把es6的新特性都编译成es5,才能在低版本浏览器中使用</p> <p><strong>@babel/polyfill</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//安装
&gt;npm i -D @babel/polyfill

//然后在需要使用它的地方,如index.js 第一行引入
import &quot;@babel/polyfill&quot;

// 这样子,会把所有的es6编译为es5需要的代码都引入,
// 一般,还要来一个,按需要引入,只引用需要的
      {
        test: /\.js$/,
        exclude: /node_modules/,
        include: path.resolve(__dirname, &quot;./src&quot;),
        loader: &quot;babel-loader&quot;,
        options: {
          presets: [
            [
              &quot;@babel/preset-env&quot;, 
              {
                targets: {
                  edge: &quot;17&quot;, 
                  firefox: &quot;60&quot;, 
                  chrome: &quot;67&quot;,
                  safari: &quot;11.1&quot;
                },
                useBuiltIns: &quot;usage&quot;,
                corejs: 2
              }
            ]
          ]
        }
      },


</code></pre></div><p>一般配置可以把单独写一上 .babelrc 文件 ,(把options字段删了)</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;presets&quot;: [
      [
        &quot;@babel/preset-env&quot;, 
        {
          &quot;targets&quot;: {
            &quot;edge&quot;: &quot;17&quot;, 
            &quot;firefox&quot;: &quot;60&quot;, 
            &quot;chrome&quot;: &quot;67&quot;,
            &quot;safari&quot;: &quot;11.1&quot;
          },
          &quot;useBuiltIns&quot;: &quot;usage&quot;,
          &quot;corejs&quot;: 2
        }
      ]
    ]
  }
</code></pre></div><ul><li>useBuiltIns 选项是 babel7的新功能,它告诉babel如何配置@babel/polyfill</li> <li>它有三个数可以用</li> <li>entry: 需要在webpack入口文件,引入imort &quot;@babel/polyfill&quot;一次,babel会根据你使用情况导入垫片, 没有使用的功能不会被导入</li> <li>usage: 不需要在入口文件import, 全自动检测, 但需要安装 @babel/polyfill,这是一个试验阶段的功能</li> <li>false: 如果入口文件 import &quot;@babel/polyfill&quot; 它不会排除没使用的垫片,体积会比较大, (不推荐使用)</li></ul> <h5 id="babel-plugin-transform-runtime"><a href="#babel-plugin-transform-runtime" class="header-anchor">#</a> @babel/plugin-transform-runtime</h5> <p>@babel/polyfill 是注入到全局变量window下, 会污染全局环境(没有贬义的意思哦),</p> <p>适合我们开发的应用  (usage 模式的行为类@babel/plugin-trnasform-runtime,不会造成全局污染, 即它不会对Array.prototype.includes()进行polyfill)</p> <p>@babel/plugin-trnasform-runtime 是闭包的方式, 不污染全局环境,适合开发组件库</p> <p>工具库时使用</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; npm i -D @babel/plugin-transform-runtime
&gt; npm i -S @babel/runtime
</code></pre></div><p><strong>注意@babel/runtime安装到生产依赖,而不是开发依赖</strong></p> <div class="language- extra-class"><pre class="language-text"><code>//rules 

</code></pre></div><p>.babelrc</p> <div class="language- extra-class"><pre class="language-text"><code>{
    &quot;presets&quot;: [
      [
        &quot;@babel/preset-env&quot;, 
        {
          &quot;targets&quot;: {
            &quot;edge&quot;: &quot;17&quot;, 
            &quot;firefox&quot;: &quot;60&quot;, 
            &quot;chrome&quot;: &quot;67&quot;,
            &quot;safari&quot;: &quot;11.1&quot;
          },
          &quot;useBuiltIns&quot;: &quot;usage&quot;,
          &quot;corejs&quot;: 2
        }
      ]
    ],
    &quot;plugins&quot;: [
        [
            &quot;@babel/plugin-transform-runtime&quot;,
            {
                &quot;absoluteRuntime&quot;: false,
                &quot;corejs&quot;: 2,
                &quot;helpers&quot;: true,
                &quot;regenerator&quot;: true,
                &quot;useESModule&quot;: false,
            }
        ]
    ]
  }
</code></pre></div><ul><li>presets 与 plugIns 取一种就可以了</li> <li>presets 是polyfill (我们一般应用开发用这个)</li> <li>pligns 是@babel/plugin-transform-runtime (库, 组件开发用这个)</li></ul> <h4 id="tree-shaking"><a href="#tree-shaking" class="header-anchor">#</a> tree shaking</h4> <p>webpack2 开始支持 tree shaking, 只支持静态引入的方式,也就是ES module的引入方式
(没有引用的文件, 就不打包进来的功能)
webpack.config.js</p> <div class="language- extra-class"><pre class="language-text"><code>optimization: {
  usedExports: true
}
</code></pre></div><p>package.json</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;sideEffects&quot;: false     //正常对所有的模块进行tree shaking
&quot;sideEffects&quot;: [&quot;*.css&quot;, &quot;@babel/polyfill&quot;]  //对css polyfill不进行tree shaking, 因为这两个模块一般没有引入内部资源
</code></pre></div><p>开发模式设置后, 需要设置sedExports: true 开启 tree shaking, 打包的文件会有注释</p> <p>提示,我们引入的文件有什么,用到什么, 但还是不会把多余代码去除</p> <p>生产模式, 会自动帮助我们摇树,可以不用设置usedExports: true, 可以删了该字段, 同时
devtool 也要配置为 &quot;cheap-module-source-map&quot;, //线上生产环境推荐配置</p> <div class="language- extra-class"><pre class="language-text"><code>import &quot;@babel/polyfill&quot;   //1
import a from './a'  
import &quot;./css/index&quot;       //2

像1  2  没有显式的导入什么东西(像a那样导入a), tree shaking 会把 polyfill index.css 摇掉,不打包进来, 所以需要在 package.js 里配置一下排除那些不要摇(见上面)
</code></pre></div><h4 id="多环境"><a href="#多环境" class="header-anchor">#</a> 多环境</h4> <p>一般是在根目录 创建一个config 目录来存放不同的打包配置文件</p> <p>一般是分为三个:</p> <ul><li>webpack.base.js</li> <li>webpack.dev.js</li> <li>webpack.pro.js</li></ul> <p>base 配置基础的东西,dev, pro都需要的东西
dev  配置 开发需要的东西
pro  配置 生产需要的东西</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; npm i -D webpack-merge 
</code></pre></div><p>webpack-merge 用来合成配置
//webpack.base.js</p> <div class="language- extra-class"><pre class="language-text"><code>const baseConfig = {

}
module.exports = baseConfig
</code></pre></div><p>//webpack.dev.js</p> <div class="language- extra-class"><pre class="language-text"><code>const merge = require(&quot;webpack-merge&quot;)
const baseConfig = require(&quot;./webpack.base.js&quot;)

const devConfig = {

}

module.exports = merge(baseConfig,devConfig)

</code></pre></div><p>//webpack.pro.js</p> <div class="language- extra-class"><pre class="language-text"><code>const merge = require(&quot;webpack-merge&quot;)
const baseConfig = require(&quot;./webpack.base.js&quot;)

const proConfig = {

}

module.exports = merge(baseConfig,proConfig)
</code></pre></div><p>在 package.js 配置不同的命令</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;webpack-dev-server --config ./config/webpack.dev.js&quot;,
  &quot;build&quot;: &quot;webpack --config ./config/webpack.pro.js&quot;
}
</code></pre></div><h4 id="基于环境变量"><a href="#基于环境变量" class="header-anchor">#</a> 基于环境变量</h4> <p>webpack.dev.js,  webpack.pro.js 就不merge, 只是导出配置,</p> <p>然后在 webpack.base.js 根据环境变量,分别merge不同的配置</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = (env) =&gt; {
  if(env &amp;&amp; env.production) {
    return merge(baseConfig, prodConfig)
  } else {
    return merge(baseConfig, devdConfig)

  }
}
</code></pre></div><p>env从哪里来? 从package.json  脚本运行命令来</p> <div class="language- extra-class"><pre class="language-text"><code>&quot;scripts&quot;: {
  &quot;dev&quot;: &quot;webpack-dev-server --env.production --config ./config/webpack.base.js&quot;,
  &quot;build&quot;: &quot;webpack --env.production --config ./config/webpack.base.js&quot;,
 
}
</code></pre></div><h4 id="code-splitting-代码分割-拆分"><a href="#code-splitting-代码分割-拆分" class="header-anchor">#</a> code Splitting  代码分割,拆分</h4> <p>如果我们引入第三方工具库, 大小1m, 我们业务代码也 1m, 那么打包出来的大小是2m</p> <p>这样体积大,加载时间长,</p> <p>事实上,业务代码会变化,而第三方库存不会变的了, 因为打包在一起,业务代码变了,第三方库存</p> <p>也跟着变了</p> <p>因此 业务代码 与 第三方库存 拆分, 很必要</p> <div class="language- extra-class"><pre class="language-text"><code>// webapck 增加配置
optimization: {
  //帮助我们自动做代码分割,  一般使用这个就可以了, 第三方库多,就可以按下面那样去配置
  splitChunks: {
    chunks: &quot;all&quot;,
  }
}
</code></pre></div><ul><li>chunks 它有三个值 同步 initial, 异步 async, all 所有模块, 不设置值,默认是async</li> <li>minSize: 30000,  // 最小大小,默认30000, 超过就进行拆分</li> <li>maxSize: 0,  //对模块进行二次分割时使用, 不推荐使用,</li> <li>minChunks: 1,// 当被引用多少次时,才进行分割</li> <li>maxAsyncRequests: 5, //最大异步请求数,默认是5, 就是页面同时异步加载的数量</li> <li>maxInitialRequests: 3, //最大初始化请求数,入口文件同步请求,默认是3</li> <li>atutomaticNameDelimiter: '~', //打包后文件名的 分割符号</li> <li>name: true, //打包后的名称, 除了布尔值 , 还可以接收一个函数</li> <li>cacheGroups:</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 当有一个模块要进行分割的时候, 它会进入下面判断, 是否属于哪一个组, 
// 然后根据该组的信息进行分割
// 一般根据引入的第三方库多少设置, 如有jquery,可以分割出一个jquery
cacheGroups: {   // 缓存组,上面name生成的名称,和这里有关联
  vendors: {
    test: /[\\/]node_modules[\\/]/,
    name: &quot;vendor&quot;, //要缓存的,分隔出来的chunk名称,
    priority: -10 // 缓存组优先级,数字越大,优先级越高
  },
  other: {
    chunks: &quot;initial&quot;, // 必须三选一, initial | all | async (默认)
    test: /react|loadash/, //正则规则验证, 如果符合就提取 chunk
    name: &quot;other&quot;,
    minSize: 30000,     //最小多大,才进行分割
    minChunks: 1,    //最少有 1 次引入
  },
  default: {
    minChunks:2,
    priority: -20,
    reuseExistingChunk: true   //可以设置是否重用该chunk
  }
}
</code></pre></div><h4 id="打包分析"><a href="#打包分析" class="header-anchor">#</a> 打包分析</h4> <p>官网有一个分析工具参考</p> <div class="language- extra-class"><pre class="language-text"><code>&gt; webpack --profile --json &gt;stats.json
// 拿到此次打包的信息
// 一般可在pakage.json 配置一条命令
&quot;scrpits&quot; {
  &quot;test&quot;: &quot;webpack --profile --json &gt;stats.json --config ./config/webpack.pro.js&quot;
}
</code></pre></div><p>然后进入分析工具的页面</p> <div class="language- extra-class"><pre class="language-text"><code>https://github.com/webpack/analyse

// 上传, stats.json 文件  生成分析的结果
</code></pre></div><p>webpack-bundle-analyzer 这个工具, 比较高大上</p> <h4 id="异步引入代码"><a href="#异步引入代码" class="header-anchor">#</a> 异步引入代码</h4> <p>把一刚始不需要使用的代码, 写到别一个文件, 提高代码使用率,就是首先加载的都是要用到的</p> <p>没用到的用异步的引入
//a.js</p> <div class="language- extra-class"><pre class="language-text"><code>function handleClick() {
  //do someting
}
export default handleClick
</code></pre></div><p>//index.js</p> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('click', ()=&gt;{
  import('./a.js').then(({default: func})=&gt; {
    // 需要用到 npm i -D @babel/plugin-syntax-dynamic-import
    func()
  })
})
</code></pre></div><p>异步引入, 有一个缺点需要去解决,就用户使用到该需要异步引入的代码时,需要等待引入</p> <p>会有一个反应时间, 需要用 预加载  来解决</p> <h4 id="预加载"><a href="#预加载" class="header-anchor">#</a> 预加载</h4> <div class="language- extra-class"><pre class="language-text"><code>document.addEventListener('click', ()=&gt;{
  import(/* webpackPrefetch: true */'./a.js').then(({default: func})=&gt; {
    // 需要用到 npm i -D @babel/plugin-syntax-dynamic-import, 新版本不需要这个
    func()
  })
})
</code></pre></div><ul><li>webpackPrefetch: true 表示, 当前主要请求都加载完毕了,当前网络空闲了,浏览器自动去请求这个资源,把它加载进来. 主chunk加载完,开始加载, 推荐使用这个.</li> <li>webpackPreload: true , 它是和主chunk 以并行方式开始加载.Pre</li></ul> <p><strong>异步加载 和 预加载 一起使用,才完美</strong></p> <h4 id="如何-编写-loader"><a href="#如何-编写-loader" class="header-anchor">#</a> 如何 编写 loader</h4> <p>loader 就是一个函数, 声明式函数, 不能用箭头函数</p> <p>拿到源代码,作进一步的修饰处理,再返回处理后的源码就可以了</p> <p>//在根目录下, 新建一个文件 loaders/replaceLoader.js</p> <div class="language- extra-class"><pre class="language-text"><code>const loaderUtils = require(&quot;loader-utils&quot;)

module.exports = function(source){
    // 传参
    // this.query   接收的是配置传递过来的options
    // const options = loaderUtils.getOptions(this)

    // 异步
    // const callback = this.async()    callback 就是this.callback
    // setTimeout(()=&gt;{
    //   callback(null, xxx)
    //},1000)


    // 返回值
    return source.replace(&quot;yycu&quot;, &quot;Kevin&quot;)
    // 如果需要返回多信息, 可以使用this.callback
    //this.callback(null, result) 和return 一样
    //this.callback(
    // err:Error|null,
    // content: string | Buffer,
    // sourceMap?: SourceMap,
    // meta?: any
    //)
};

</code></pre></div><ul><li>一定要用声明式函数,不能用箭头函数, 且必须返回,(用return 或this.callback())</li> <li>this.callback 可以返更多的信息</li> <li>this.asycn 处理异步, 他会返回 this.callback</li></ul> <p>//使用 webpack.base.js</p> <div class="language- extra-class"><pre class="language-text"><code>module: {
    rules: [
        {
            test: /\.js$/,
            use: path.join(__dirname, &quot;./loaders/replaceLoader.js&quot;)
        }
    ]
}

// 传参
{
  test: /\.js$/,
  use: [
        loader: path.join(__dirname, &quot;./loaders/replaceLoader.js&quot;), 
        {
            loader: path
            options: {
                name: &quot;陈生&quot;
            }
        }
      
  ]
}
</code></pre></div><ul><li>官方推荐 loder-utils 处理loader query</li></ul> <h5 id="使用多个loader"><a href="#使用多个loader" class="header-anchor">#</a> 使用多个loader</h5> <p>//replaceLoaderAsync.js</p> <div class="language- extra-class"><pre class="language-text"><code>module.exports = function(source) {
    const options = this.query
    const callback = this.async()
    console.log(this.query)
    setTimeout(() =&gt; {

        callback(null, source.replace('yycu', this.query.name))
    }, 3000);

};

</code></pre></div><p>//webpack.base.js</p> <div class="language- extra-class"><pre class="language-text"><code>resolveLoader: {
  modules: [&quot;node_modules&quot;, &quot;./loader&quot;]
}
module:{
  rules: [
      {
          test: /\.js$/,
          use: [
              &quot;replaceLoader&quot;,
              {
                  loader: &quot;replaceLoaderAsync&quot;, 
                  options: {
                      name: &quot;陈生&quot;
                  }
              }
              
          ]
      }       
  ]
} 
</code></pre></div><ul><li>resolveLoader 定义loader的查找路径, 我们引入时就不用写路径了,只写个名称</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/frontend/tools/" class="prev router-link-active">
        tools
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.a761fdad.js" defer></script><script src="/assets/js/2.f625eefe.js" defer></script><script src="/assets/js/38.d197d8d0.js" defer></script>
  </body>
</html>
